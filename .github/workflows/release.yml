# filepath: .github/workflows/release.yml

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag for this release (e.g., v1.2.3)'
        required: true
        type: string
      draft:
        description: 'Create as draft release'
        required: false
        default: true
        type: boolean

permissions:
  contents: write  # This allows the action to create releases

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for version history

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18.x'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Update version in package.json
        id: update_version
        run: |
          # Extract version from tag (e.g., v1.2.3 -> 1.2.3)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Use the manually provided tag from workflow_dispatch
            RAW_TAG="${{ github.event.inputs.tag_name }}"
          else
            # Use the tag that triggered the workflow
            RAW_TAG=${GITHUB_REF#refs/tags/}
          fi
          
          # Remove 'v' prefix if present
          TAG_VERSION=${RAW_TAG#v}
          echo "TAG_VERSION=$TAG_VERSION" >> $GITHUB_ENV
          echo "RAW_TAG=$RAW_TAG" >> $GITHUB_ENV
          
          # Get current version
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          
          if [ "$CURRENT_VERSION" != "$TAG_VERSION" ]; then
            echo "Updating version from $CURRENT_VERSION to $TAG_VERSION"
            # Use Node.js to update the version in package.json
            node -e "
              const fs = require('fs');
              const package = JSON.parse(fs.readFileSync('./package.json'));
              package.version = '$TAG_VERSION';
              fs.writeFileSync('./package.json', JSON.stringify(package, null, 2) + '\n');
            "
          else
            echo "Version is already up to date ($CURRENT_VERSION)"
          fi
          
          echo "VSIX_FILE=tech-debt-extension-$TAG_VERSION.vsix" >> $GITHUB_ENV

      - name: Build extension
        run: yarn run compile

      - name: Run linting
        run: yarn run lint

      - name: Package VSIX
        run: yarn run build-vsix

      - name: Install GitHub CLI
        run: |
          sudo apt install gh -y

      - name: Extract Changelog Section
        id: extract_changelog
        run: |
          # Print CHANGELOG.md contents for debugging
          echo "CHANGELOG.md contents (first 10 lines):"
          head -n 10 CHANGELOG.md
          
          # Print the version we're looking for
          echo "Looking for version: ${{ env.TAG_VERSION }}"
          
          # Format the version pattern for grep
          VERSION_PATTERN="## \\[${{ env.TAG_VERSION }}\\]"
          echo "Searching for pattern: $VERSION_PATTERN"
          
          # Create a robust script to extract the changelog section
          cat > extract_changelog.sh << 'EOF'
          #!/bin/bash
          set -e
          
          CHANGELOG_FILE="CHANGELOG.md"
          VERSION="$1"
          
          # Escape brackets for grep
          VERSION_PATTERN="## \\[$VERSION\\]"
          
          # Find the line number of our version
          VERSION_LINE=$(grep -n "$VERSION_PATTERN" "$CHANGELOG_FILE" | cut -d ':' -f 1 || echo "")
          
          if [ -z "$VERSION_LINE" ]; then
            echo "Error: Version $VERSION not found in changelog" >&2
            echo "See full changelog for details." > changelog_section.md
            exit 0
          fi
          
          echo "Found version header at line: $VERSION_LINE" >&2
          
          # Find the line number of the next version header
          NEXT_LINE=$(tail -n "+$((VERSION_LINE + 1))" "$CHANGELOG_FILE" | grep -n "^## " | head -n 1 | cut -d ':' -f 1 || echo "")
          
          if [ -z "$NEXT_LINE" ]; then
            # No next version found, extract until the end of file
            tail -n "+$((VERSION_LINE))" "$CHANGELOG_FILE" > changelog_section.md
          else
            # Calculate the number of lines to extract (including the version header)
            LINES_TO_EXTRACT=$((NEXT_LINE))
            
            # Extract section including our version header and excluding the next version header
            tail -n "+$((VERSION_LINE))" "$CHANGELOG_FILE" | head -n "$LINES_TO_EXTRACT" > changelog_section.md
          fi
          
          echo "Extracted changelog section:" >&2
          cat changelog_section.md >&2
          EOF
          
          # Make the script executable
          chmod +x extract_changelog.sh
          
          # Run the script
          ./extract_changelog.sh "${{ env.TAG_VERSION }}"
          
          # Check if extraction was successful
          if [ -f "changelog_section.md" ]; then
            echo "CHANGELOG_EXTRACTED=true" >> $GITHUB_ENV
          else
            echo "Warning: Failed to extract changelog section" >&2
            echo "See full changelog for details." > changelog_section.md
            echo "CHANGELOG_EXTRACTED=true" >> $GITHUB_ENV
          fi

      - name: Create GitHub Release and Upload VSIX
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release notes file
          echo "# Tech Debt Manager v${{ env.TAG_VERSION }}" > release_notes.md
          echo "" >> release_notes.md
          
          # Add extracted changelog section if it exists
          if [ -f "changelog_section.md" ]; then
            echo "## What's Changed" >> release_notes.md
            echo "" >> release_notes.md
            
            # Exclude the version header line from changelog_section.md
            grep -v "^## " changelog_section.md >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          echo "## Installation" >> release_notes.md
          echo "Download the VSIX file from this release and install it manually in VS Code:" >> release_notes.md
          echo '1. Go to Extensions view (`Ctrl+Shift+X`)' >> release_notes.md
          echo '2. Click the "..." menu in the top-right' >> release_notes.md
          echo '3. Select "Install from VSIX..."' >> release_notes.md
          echo '4. Choose the downloaded VSIX file' >> release_notes.md
          
          # Debug information
          echo "Debug: Final release notes content:"
          cat release_notes.md
          
          echo "Debug: Checking repository info"
          gh repo view

          # Create the release (draft or not depending on input)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.draft }}" == "false" ]; then
            echo "Creating a public release..."
            gh release create "${{ env.RAW_TAG }}" \
              --title "Tech Debt Manager v${{ env.TAG_VERSION }}" \
              --notes-file release_notes.md
          else
            echo "Creating a draft release..."
            gh release create "${{ env.RAW_TAG }}" \
              --title "Tech Debt Manager v${{ env.TAG_VERSION }}" \
              --notes-file release_notes.md \
              --draft
          fi
            
          # Upload the asset
          gh release upload "${{ env.RAW_TAG }}" "${{ env.VSIX_FILE }}" --clobber
      
      - name: Commit version change
        if: env.CURRENT_VERSION != env.TAG_VERSION && github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json
          git commit -m "ci: bump version to ${{ env.TAG_VERSION }}"
          
          # Create and push the tag if it doesn't exist (for workflow_dispatch)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Creating and pushing tag ${{ env.RAW_TAG }}"
            git tag ${{ env.RAW_TAG }}
            git push origin ${{ env.RAW_TAG }}
          fi
          
          # Push changes to package.json
          git push
